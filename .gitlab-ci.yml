# Pipelines run on devel/stable branch and merge requests
workflow:
  rules:
    - if: $CI_COMMIT_REF_NAME == 'devel'
    - if: $CI_COMMIT_REF_NAME == 'stable'
    - if: $CI_MERGE_REQUEST_EVENT_TYPE

stages:
- lint
- spawn-cluster
- cluster-upgrades
- deploy

tflint:
  image:
    name: wata727/tflint:latest
    entrypoint: ["/bin/sh", "-c"]
  stage: lint
  script:
    - tflint terraform
  tags:
    - docker

shellcheck:
  variables:
    SHELLCHECK_IMAGE_TAG: v0.7.2
  image: koalaman/shellcheck-alpine:$SHELLCHECK_IMAGE_TAG
  stage: lint
  script:
    - "find -iname '*.sh' '!' -ipath './jsonnet-sources/*/vendor/**' '!' -ipath './.git/**' -print0 | xargs -0 -- shellcheck -Calways"
  tags:
    - docker

yamllint:
  stage: lint
  tags:
    - docker
  image: registry.gitlab.com/pipeline-components/yamllint:latest
  script:
    - yamllint .

ansible-lint:
  image:
    name: cytopia/ansible-lint:5-0.6
    entrypoint: ["/bin/sh", "-c"]
  stage: lint
  script:
    - "ansible-galaxy install -r ansible/requirements.yaml" # Install requirements
    - "ansible-lint -c ci/lint/ansible-lint-conf k8s-base/install_frontend.yaml" # Check stage 2
    - "ansible-lint -c ci/lint/ansible-lint-conf k8s-base/install_k8s_base.yaml" # Check stage 3
    - "ansible-lint -c ci/lint/ansible-lint-conf k8s-service-layer/install.yaml" # Check stage 4
    - "ansible-lint -c ci/lint/ansible-lint-conf k8s-managed-services/install.yaml" # Check stage 5
    - "ANSIBLE_ROLES_PATH=k8s-base/test-roles ansible-lint -c ci/lint/ansible-lint-conf k8s-base/test.yaml" # Check smoke tests
    - "ANSIBLE_ROLES_PATH=k8s-service-layer/test-roles ansible-lint -c ci/lint/ansible-lint-conf k8s-service-layer/test.yaml" # Check ksl tests
    - "ANSIBLE_ROLES_PATH=k8s-managed-services/test-roles ansible-lint -c ci/lint/ansible-lint-conf k8s-managed-services/test.yaml" # Check ksm tests
    - "ansible-lint -c ci/lint/ansible-lint-conf k8s-base/system_update_nodes.yaml" # Check system update node
      # Check k8s upgrades
    - "ANSIBLE_ROLES_PATH=k8s-base/roles ansible-lint -c ci/lint/ansible-lint-conf  k8s-base/k8s-upgrades/k8s_upgrade_to_1.20.yaml"
    - "ANSIBLE_ROLES_PATH=k8s-base/roles ansible-lint -c ci/lint/ansible-lint-conf  k8s-base/k8s-upgrades/k8s_upgrade_to_1.21.yaml"
    - "ANSIBLE_ROLES_PATH=k8s-base/roles ansible-lint -c ci/lint/ansible-lint-conf  k8s-base/k8s-upgrades/k8s_upgrade_to_1.22.yaml"
    - "ANSIBLE_ROLES_PATH=k8s-base/roles ansible-lint -c ci/lint/ansible-lint-conf  k8s-base/k8s-upgrades/k8s_upgrade_to_1.23.yaml"
  tags:
    - docker

flake8:
  image: python:3
  script:
    - "pip3 install flake8"
    - 'python3 -m flake8 --max-line-length 88 --filename="*.py"'
  stage: lint
  tags:
    - docker

testBook:
  stage: lint
  image: rust
  variables:
    CARGO_HOME: $CI_PROJECT_DIR/cargo
  before_script:
    - export PATH="$PATH:$CARGO_HOME/bin"
    - mdbook --version || cargo install mdbook
    - mdbook-linkcheck --version || cargo install mdbook-linkcheck
  script:
    - mdbook build docs
    - cp -r docs/book/html public
  rules:
    - when: always
  artifacts:
    expose_as: "Rendered Docs"
    expire_in: "7 days"
    paths:
      - public/
  tags:
    - docker
  cache:
    paths:
      - $CARGO_HOME/bin

# Tests the Vault in Docker dev deployment.
# It mainly tests the defined config.hcl settings.
# The certificates and config are stored within the CI vars,
# as the service instance is limited in accessing data from the
# repo while it's starting, so they have to be stored elsewhere.
vault-container-test:
  stage: deploy
  image: "registry.gitlab.com/yaook/images/k8s-ci/f1a:devel"
  variables:
    GIT_CLEAN_FLAGS: -ffd $CI_PROJECT_DIR -e vault
    VAULT_TLS_DIR: $CI_PROJECT_DIR/ci/vault/tls
    VAULT_KEY: $ci_cert_vault_key
    VAULTCA_CRT: $ci_cert_vaultca_crt
    VAULTCHAIN_CRT: $ci_cert_vaultchain_crt
    VAULT_CONFIG_HCL: $ci_vault_config_hcl
  services:
    - name: vault:1.12.2
      alias: yaook-vault
      entrypoint: ["sh", "-c"]
      command:
        - |
          export VAULT_ADDR=https://127.0.0.1:8200
          mkdir -p /vault/config /vault/tls/ca
          printf "%s" "$VAULT_KEY" > /vault/tls/vault.key
          printf "%s" "$VAULTCHAIN_CRT" > /vault/tls/vaultchain.crt
          printf "%s" "$VAULT_CONFIG_HCL" > /vault/config/config.hcl
          cp /bin/vault $CI_PROJECT_DIR
          exec vault server -config=/vault/config/config.hcl
  script:
    - export VAULT_ADDR=https://yaook-vault:8200
    - mkdir -p $CI_PROJECT_DIR/tls/ca
    - printf "%s" "$VAULTCA_CRT" > $CI_PROJECT_DIR/tls/ca/vaultca.crt
    - export VAULT_CACERT="$CI_PROJECT_DIR/tls/ca/vaultca.crt"
    - $CI_PROJECT_DIR/vault operator init -key-shares=1 -key-threshold=1 -format=json > $CI_PROJECT_DIR/vault_init.out
    - jq .root_token -c $CI_PROJECT_DIR/vault_init.out -r | tee $CI_PROJECT_DIR/root.key
    - jq .unseal_keys_b64[0] -c $CI_PROJECT_DIR/vault_init.out -r | tee $CI_PROJECT_DIR/unseal.key
    - $CI_PROJECT_DIR/vault operator unseal $(cat $CI_PROJECT_DIR/unseal.key)
    - $CI_PROJECT_DIR/vault login $(cat $CI_PROJECT_DIR/root.key)
  tags:
  - docker

.prepare_spawn_test_cleanup_k8s_cluster:
  image: "registry.gitlab.com/yaook/images/k8s-ci/f1a:devel"
  variables:
    WG_COMPANY_USERS: "false"
    PASS_COMPANY_USERS: "false"
    SSH_COMPANY_USERS: "false"
    ANSIBLE_ANY_ERRORS_FATAL: "true"
    ANSIBLE_FORCE_COLOR: "true"
  before_script:
    - "export wg_conf_name=wg0"
    # id_rsa must be set as `File` input in the GitLab CI/CD variables of the
    # repository.
    - 'cp "$id_rsa" /root/.ssh/id_rsa && chmod go-rwx -R /root/.ssh'
    # OS_PASSWORD must be set as `Variable` input in the GitLab CI/CD variables of
    # the repository.
    - . /root/openrc.sh
    - git clean -f .
    - "chmod o-w *"
    - rm -rf ci # make sure we're operating on a clean directory
    - git checkout -- ci
    - export MANAGED_K8S_GIT="$(realpath .)"
    - cd ci
    - git init
    - ../actions/init.sh
    - ../actions/init.sh # A second run to check idempotency
      # Note that this is basically a dummy keypair that is not used to protect any significant data
    - gpg --quick-generate-key --batch --passphrase '' mk8s-ci@gitlab rsa1024 encr never
      # Ensure that the project is clean
    - python3 clean-up-os-project.py

    # Creates a psk for ipsec. IPSEC_EAP_PSK must be set as `Variable` input in the GitLab CI/CD
    # variables of the repository.
    - export PASSWORD_STORE_DIR=$(pwd)/inventory/.etc/passwordstore
    - pass init mk8s-ci@gitlab
    - echo ${IPSEC_EAP_PSK} | pass insert -m ipsec_eap_psk
    - unset PASSWORD_STORE_DIR

  script:
    - pip3 install -r managed-k8s/requirements.txt
    - ./managed-k8s/actions/apply-terraform.sh
    - ./reachability-or-recreate.sh
    - ./managed-k8s/actions/apply-stage2.sh
    - ./managed-k8s/actions/apply-stage3.sh
    - ./managed-k8s/actions/apply-stage4.sh
    - ./managed-k8s/actions/apply-stage5.sh
    - MANAGED_K8S_RELEASE_THE_KRAKEN=true ./managed-k8s/actions/system_update_nodes.sh
    - ./managed-k8s/actions/test.sh
  after_script:
    - cd ci/
    - ./after_script_cleanup.sh
  artifacts:
    paths:
      - ci/podlogs/
    when: always
  tags:
    - docker
    - wireguard-ready

.test_upgrade_path_k8s_cluster:
  image: "registry.gitlab.com/yaook/images/k8s-ci/f1a:devel"
  variables: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables]
  before_script:
  - !reference [.prepare_spawn_test_cleanup_k8s_cluster, before_script]
  script:
    # Set k8s version to minimal supported version: v1.19.16
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"kubernetes\":{\"version\":\"1.19.16\"}}"'
    # Disable Ingress (Requires k8s >= v1.20)
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"k8s-service-layer\":{\"ingress\":{\"enabled\":\"false\"}}}"'
    # Disable Cert-Manager (Requires k8s >= v1.20)
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"k8s-service-layer\":{\"cert-manager\":{\"enabled\":\"false\"}}}"'
    # We can't use vault without cert-manager
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"k8s-service-layer\":{\"vault\":{\"enabled\":\"false\"}}}"'
    # Spawn and test cluster
  - !reference [.prepare_spawn_test_cleanup_k8s_cluster, script]
    # Upgrade cluster to k8s v1.20.15
  - MANAGED_K8S_RELEASE_THE_KRAKEN=true ./managed-k8s/actions/upgrade.sh 1.20.15
    # Update k8s version
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"kubernetes\":{\"version\":\"1.20.15\"}}"'
    # Upgrade cluster to k8s v1.21.14
  - MANAGED_K8S_RELEASE_THE_KRAKEN=true ./managed-k8s/actions/upgrade.sh 1.21.14
    # Update k8s version
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"kubernetes\":{\"version\":\"1.21.14\"}}"'
    # Install ingress, cert-manager & vault after upgrading to k8s v1.21
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"k8s-service-layer\":{\"ingress\":{\"enabled\":\"true\"}}}"'
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"k8s-service-layer\":{\"cert-manager\":{\"enabled\":\"true\"}}}"'
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"k8s-service-layer\":{\"vault\":{\"enabled\":\"true\"}}}"'
  - AFLAGS="-t mk8s-sl/ingress,mk8s-sl/cert-manager,mk8s-sl/vault" ./managed-k8s/actions/apply-stage4.sh
    # Upgrade cluster to k8s v1.22.12
  - MANAGED_K8S_RELEASE_THE_KRAKEN=true ./managed-k8s/actions/upgrade.sh 1.22.12
    # Update k8s version
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"kubernetes\":{\"version\":\"1.22.12\"}}"'
    # Upgrade cluster to k8s v1.23.13
  - MANAGED_K8S_RELEASE_THE_KRAKEN=true ./managed-k8s/actions/upgrade.sh 1.23.13
    # Update k8s version
  - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"kubernetes\":{\"version\":\"1.23.13\"}}"'
    # Retest the cluster
  - ./managed-k8s/actions/test.sh
  after_script:
  - !reference [.prepare_spawn_test_cleanup_k8s_cluster, after_script]
  artifacts: !reference [.prepare_spawn_test_cleanup_k8s_cluster, artifacts]
  tags: !reference [.prepare_spawn_test_cleanup_k8s_cluster, tags]

# Spawn a cluster with calico as CNI and rook enabled
docker:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: never
    - when: on_success
  extends: .prepare_spawn_test_cleanup_k8s_cluster
  script:
    - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"miscellaneous\":{\"container_runtime\":\"docker\"}}"'
    - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"kubernetes\":{\"is_gpu_cluster\":true}}"'
    - !reference [.prepare_spawn_test_cleanup_k8s_cluster, script]
  stage: spawn-cluster
  retry: 2

# Manually spawn a cluster with calico as CNI and rook enabled (MR only)
docker-manual:
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - when: never
  extends: docker
  allow_failure: true
  retry: 0

# Spawn a cluster and test the k8s upgrade path (w/ calico)
containerd-k8s-upgrade:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: never
    - if: $CI_COMMIT_REF_NAME == 'devel'
      when: never
    - if: $CI_COMMIT_REF_NAME == 'stable'
      when: never
    - when: on_success
  extends: .test_upgrade_path_k8s_cluster
  stage: cluster-upgrades
  retry: 2
  variables:
    # the variables defined in .test_upgrade_path_k8s_cluster get overwritten,
    # so we need to reference the default vars here (only one level of nesting is allowed)
    WG_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, WG_COMPANY_USERS]
    PASS_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, PASS_COMPANY_USERS]
    SSH_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, SSH_COMPANY_USERS]
    ANSIBLE_ANY_ERRORS_FATAL: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_ANY_ERRORS_FATAL]
    ANSIBLE_FORCE_COLOR: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_FORCE_COLOR]

# Manually spawn a cluster and test the k8s upgrade path (w/ calico)
containerd-k8s-upgrade-manual:
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - if: $CI_COMMIT_REF_NAME == 'devel'
      when: manual
    - if: $CI_COMMIT_REF_NAME == 'stable'
      when: manual
    - when: never
  extends: containerd-k8s-upgrade
  allow_failure: true
  retry: 0

# Spawn a cluster with calico as CNI, containerd as CRI and
# rook enabled (MR only)
# Note on k8s_is_gpu_cluster: This needs to be disabled (as
# containerd-GPU-clusters don't work and error out loudly).
# The ugly formatting of the config patches is necessary due to the
# way gitlab CI passes the commands to the shell.
containerd:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: never
    - when: on_success
  extends: .prepare_spawn_test_cleanup_k8s_cluster
  stage: spawn-cluster
  script:
  - !reference [.prepare_spawn_test_cleanup_k8s_cluster, script]
  retry: 2
  variables:
    # the variables defined in .test_upgrade_path_k8s_cluster get overwritten,
    # so we need to reference the default vars here (only one level of nesting is allowed)
    WG_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, WG_COMPANY_USERS]
    PASS_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, PASS_COMPANY_USERS]
    SSH_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, SSH_COMPANY_USERS]
    ANSIBLE_ANY_ERRORS_FATAL: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_ANY_ERRORS_FATAL]
    ANSIBLE_FORCE_COLOR: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_FORCE_COLOR]

# Manually spawn a cluster with calico as CNI, containerd as CRI and
# rook enabled (MR only)
containerd-manual:
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - when: never
  allow_failure: true
  extends: containerd
  retry: 0

# Spawn a cluster and test the k8s upgrade path (w/ calico)
docker-k8s-upgrade:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: never
    - if: $CI_COMMIT_REF_NAME == 'devel'
      when: never
    - if: $CI_COMMIT_REF_NAME == 'stable'
      when: never
    - when: on_success
  script:
    - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"miscellaneous\":{\"container_runtime\":\"docker\"}}"'
    - 'python3 managed-k8s/tools/patch_config.py --patch-config "{\"kubernetes\":{\"is_gpu_cluster\":true}}"'
    - !reference [.test_upgrade_path_k8s_cluster, script]
  extends: .test_upgrade_path_k8s_cluster
  stage: cluster-upgrades
  retry: 2
  variables:
    # the variables defined in .test_upgrade_path_k8s_cluster get overwritten,
    # so we need to reference the default vars here (only one level of nesting is allowed)
    WG_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, WG_COMPANY_USERS]
    PASS_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, PASS_COMPANY_USERS]
    SSH_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, SSH_COMPANY_USERS]
    ANSIBLE_ANY_ERRORS_FATAL: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_ANY_ERRORS_FATAL]
    ANSIBLE_FORCE_COLOR: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_FORCE_COLOR]

# Manually spawn a cluster and test the k8s upgrade path (w/ calico)
docker-k8s-upgrade-manual:
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - if: $CI_COMMIT_REF_NAME == 'devel'
      when: manual
    - if: $CI_COMMIT_REF_NAME == 'stable'
      when: manual
    - when: never
  extends: docker-k8s-upgrade
  allow_failure: true
  retry: 0

pages:
  stage: deploy
  image: rust
  variables:
    CARGO_HOME: $CI_PROJECT_DIR/cargo
  before_script:
    - export PATH="$PATH:$CARGO_HOME/bin"
    - mdbook --version || cargo install mdbook
    - mdbook-linkcheck --version || cargo install mdbook-linkcheck
  script:
    - mdbook build docs
    - cp -r docs/book/html public
  rules:
    - if: "$CI_COMMIT_REF_NAME =~ /^(devel|stable)$/"
      when: always
    - when: never
  artifacts:
    paths:
      - public/
  tags:
    - docker
  cache:
    paths:
      - $CARGO_HOME/bin
