# Pipelines run on devel/stable branch and merge requests
workflow:
  rules:
    - if: $CI_COMMIT_REF_NAME == 'devel'
    - if: $CI_COMMIT_REF_NAME == 'stable'
    - if: $CI_MERGE_REQUEST_EVENT_TYPE

stages:
- lint
- spawn-cluster
- cluster-upgrades
- deploy

tflint:
  image:
    name: wata727/tflint:latest
    entrypoint: ["/bin/sh", "-c"]
  stage: lint
  script:
  - tflint terraform
  tags:
  - docker

shellcheck:
  variables:
    SHELLCHECK_IMAGE_TAG: v0.7.2
  image: koalaman/shellcheck-alpine:$SHELLCHECK_IMAGE_TAG
  stage: lint
  script:
  - "find -iname '*.sh' '!' -ipath './jsonnet-sources/*/vendor/**' '!' -ipath './.git/**' -print0 | xargs -0 -- shellcheck -Calways"
  tags:
  - docker

ansible-lint:
  variables:
    ANSIBLE_LINT_IMAGE_TAG: 5
  image:
    name: cytopia/ansible-lint:$ANSIBLE_LINT_IMAGE_TAG
    entrypoint: ["/bin/sh", "-c"]
  stage: lint
  script:
  - 'ansible-galaxy install -r ansible/requirements.yaml'                           # Install requirements
  - 'ansible-lint -c ci/lint/ansible-lint-conf k8s-base/install_frontend.yaml'         # Check stage 2
  - 'ansible-lint -c ci/lint/ansible-lint-conf k8s-base/install_k8s_base.yaml'           # Check stage 3
  - 'ansible-lint -c ci/lint/ansible-lint-conf k8s-service-layer/install.yaml'     # Check stage 4
  - 'ansible-lint -c ci/lint/ansible-lint-conf k8s-managed-services/install.yaml'  # Check stage 5
  - 'ansible-lint -c ci/lint/ansible-lint-conf k8s-base/test.yaml'              # Check smoke tests
  - 'ansible-lint -c ci/lint/ansible-lint-conf k8s-service-layer/test.yaml'        # Check ksl tests
  - 'ansible-lint -c ci/lint/ansible-lint-conf k8s-managed-services/test.yaml'     # Check ksm tests
  tags:
  - docker

flake8:
  image: python:3
  script:
  - 'pip3 install flake8'
  - 'python3 -m flake8 --filename="*.py"'
  stage: lint
  tags:
  - docker

testBook:
  stage: lint
  image: rust
  variables:
    CARGO_HOME: $CI_PROJECT_DIR/cargo
  before_script:
    - export PATH="$PATH:$CARGO_HOME/bin"
    - mdbook --version || cargo install mdbook
  script:
    - mdbook build docs -d ../public
  rules:
  - when: always
  artifacts:
    expose_as: "Rendered Docs"
    expire_in: '7 days'
    paths:
      - public/
  tags:
  - docker
  cache:
    paths:
      - $CARGO_HOME/bin

.prepare_spawn_test_cleanup_k8s_cluster:
  image: "registry.gitlab.com/yaook/images/k8s-ci/f1a:devel"
  variables:
    WG_COMPANY_USERS: "false"
    PASS_COMPANY_USERS: "false"
    SSH_COMPANY_USERS: "false"
    ANSIBLE_ANY_ERRORS_FATAL: "true"
    ANSIBLE_FORCE_COLOR: "true"
  before_script:
  - 'export wg_conf_name=wg0'
  # id_rsa must be set as `File` input in the GitLab CI/CD variables of the
  # repository.
  - 'cp "$id_rsa" /root/.ssh/id_rsa && chmod go-rwx -R /root/.ssh'
  # OS_PASSWORD must be set as `Variable` input in the GitLab CI/CD variables of
  # the repository.
  - . /root/openrc.sh
  - git clean -f .
  - 'chmod o-w *'
  - rm -rf ci # make sure we're operating on a clean directory
  - git checkout -- ci
  - export MANAGED_K8S_GIT="$(realpath .)"
  - cd ci
  - git init
  - ../actions/init.sh
  - ../actions/init.sh # A second run to check idempotency
    # Note that this is basically a dummy keypair that is not used to protect any significant data
  - gpg --quick-generate-key --batch --passphrase '' mk8s-ci@gitlab rsa1024 encr never
  script:
  - pip3 install -r managed-k8s/requirements.txt
  - ./managed-k8s/actions/apply-terraform.sh
  - ./reachability-or-recreate.sh
  - ./retry_and_timeout.sh ./managed-k8s/actions/apply-stage2.sh 2 40m
  - ./retry_and_timeout.sh ./managed-k8s/actions/apply-stage3.sh 2 80m
  - ./retry_and_timeout.sh ./managed-k8s/actions/apply-stage4.sh 2 30m
  - ./retry_and_timeout.sh ./managed-k8s/actions/apply-stage5.sh 2 30m
  - ./retry_and_timeout.sh ./managed-k8s/actions/test.sh 2 30m
  after_script:
  - cd ci/
  - ./cleanup.sh
  artifacts:
    paths:
      - ci/podlogs/
    when: always
  tags:
  - docker
  - wireguard-ready
  resource_group: ch-k8s-ci-environment-f1a-1

.test_upgrade_path_k8s_cluster:
  image: "registry.gitlab.com/yaook/images/k8s-ci/f1a:devel"
  variables: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables]
  before_script:
  - !reference [.prepare_spawn_test_cleanup_k8s_cluster, before_script]
  script:
  # Set k8s version to minimal supported version
  - export AFLAGS="$AFLAGS_BASE -e k8s_version='1.19.16'"
  # Spawn and test cluster
  - !reference [.prepare_spawn_test_cleanup_k8s_cluster, script]
    # Upgrade cluster to k8s v1.20.4
  - MANAGED_K8S_RELEASE_THE_KRAKEN=true ./managed-k8s/actions/upgrade.sh 1.20.14
    # Update k8s version
  - export AFLAGS="$AFLAGS_BASE -e k8s_version='1.20.14'"
    # Retest the cluster
  - ./retry_and_timeout.sh ./managed-k8s/actions/test.sh 2 30m
    # Upgrade cluster to k8s v1.21.8
  - MANAGED_K8S_RELEASE_THE_KRAKEN=true ./managed-k8s/actions/upgrade.sh 1.21.8
    # Update k8s version
  - export AFLAGS="$AFLAGS_BASE -e k8s_version='1.21.8'"
    # Retest the cluster
  - ./retry_and_timeout.sh ./managed-k8s/actions/test.sh 2 30m
  after_script:
  - !reference [.prepare_spawn_test_cleanup_k8s_cluster, after_script]
  artifacts: !reference [.prepare_spawn_test_cleanup_k8s_cluster, artifacts]
  tags: !reference [.prepare_spawn_test_cleanup_k8s_cluster, tags]
  resource_group: !reference [.prepare_spawn_test_cleanup_k8s_cluster, resource_group]

# Spawn a cluster with kube-router as CNI and rook enabled
kuberouter-rook:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: never
    - when: on_success
  extends: .prepare_spawn_test_cleanup_k8s_cluster
  stage: spawn-cluster

# Manually spawn a cluster with kube-router as CNI and rook enabled (MR only)
kuberouter-rook-manual:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - when: never
  extends: .prepare_spawn_test_cleanup_k8s_cluster
  allow_failure: true
  stage: spawn-cluster

# Spawn a cluster with calico as CNI and rook enabled
calico-rook-dualstack:
  environment:
    name: spawn-cluster
  rules:
  - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
    when: never
  - when: on_success
  extends: .prepare_spawn_test_cleanup_k8s_cluster
  stage: spawn-cluster
  variables:
    AFLAGS: "-e k8s_network_plugin=calico"
    TF_VAR_dualstack_support: "true"

# Manually spawn a cluster with calico as CNI and rook enabled (MR only)
calico-rook-dualstack-manual:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - when: never
  extends: .prepare_spawn_test_cleanup_k8s_cluster
  allow_failure: true
  stage: spawn-cluster
  variables:
    AFLAGS: "-e k8s_network_plugin=calico"
    TF_VAR_dualstack_support: "true"

# Spawn a cluster and test the k8s upgrade path (w/ kube-router)
k8s-upgrade-kube-router:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: never
    - when: on_success
  extends: .test_upgrade_path_k8s_cluster
  stage: cluster-upgrades

# Manually spawn a cluster and test the k8s upgrade path (w/ kube-router)
k8s-upgrade-kube-router-manual:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - when: never
  extends: .test_upgrade_path_k8s_cluster
  stage: cluster-upgrades
  allow_failure: true

# Spawn a cluster and test the k8s upgrade path (w/ calico)
k8s-upgrade-calico:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: never
    - when: on_success
  extends: .test_upgrade_path_k8s_cluster
  stage: cluster-upgrades
  variables:
    AFLAGS_BASE: "-e k8s_network_plugin=calico"
    # the variables defined in .test_upgrade_path_k8s_cluster get overwritten,
    # so we need to reference the default vars here (only one level of nesting is allowed)
    WG_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, WG_COMPANY_USERS]
    PASS_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, PASS_COMPANY_USERS]
    SSH_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, SSH_COMPANY_USERS]
    ANSIBLE_ANY_ERRORS_FATAL: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_ANY_ERRORS_FATAL]
    ANSIBLE_FORCE_COLOR: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_FORCE_COLOR]

# Manually spawn a cluster and test the k8s upgrade path (w/ calico)
k8s-upgrade-calico-manual:
  environment:
    name: spawn-cluster
  rules:
    - if: '$CI_MERGE_REQUEST_EVENT_TYPE == "detached" || $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"'
      when: manual
    - when: never
  extends: .test_upgrade_path_k8s_cluster
  stage: cluster-upgrades
  allow_failure: true
  variables:
    AFLAGS_BASE: "-e k8s_network_plugin=calico"
    # the variables defined in .test_upgrade_path_k8s_cluster get overwritten,
    # so we need to reference the default vars here (only one level of nesting is allowed)
    WG_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, WG_COMPANY_USERS]
    PASS_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, PASS_COMPANY_USERS]
    SSH_COMPANY_USERS: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, SSH_COMPANY_USERS]
    ANSIBLE_ANY_ERRORS_FATAL: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_ANY_ERRORS_FATAL]
    ANSIBLE_FORCE_COLOR: !reference [.prepare_spawn_test_cleanup_k8s_cluster, variables, ANSIBLE_FORCE_COLOR]

pages:
  stage: deploy
  image: rust
  variables:
    CARGO_HOME: $CI_PROJECT_DIR/cargo
  before_script:
    - export PATH="$PATH:$CARGO_HOME/bin"
    - mdbook --version || cargo install mdbook
  script:
    - mdbook build docs -d ../public
  rules:
  - if: '$CI_COMMIT_REF_NAME =~ /^(devel|stable)$/'
    when: always
  - when: never
  artifacts:
    paths:
      - public/
  tags:
  - docker
  cache:
    paths:
      - $CARGO_HOME/bin
