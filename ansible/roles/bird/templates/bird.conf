router id {{ local_ipv4_address }};
table ipsec;
table master;
debug protocols all;

protocol kernel {
    table master;
    scan time 60;
    import none;
    export all;
}

protocol kernel ipsec2 {
    # learn alien routes
    learn;
    table ipsec;
    scan time 60;
    kernel table 220;
    import filter {
        print "import - route: ", net;
        accept;
    };
    export filter {
        print "export - route: ", net;
        reject;
    };
}

protocol pipe {
    table ipsec;
    peer table master;
    import none;
    export all;
}

protocol direct {
    table master;
    import all;
    export none;
}

protocol device {
    table master;
    scan time 60;
    import none;
    export all;
}

protocol static {
    table master;
    # FIXME: this hardcodes the first master as nexthop for cluster IP access.
    # That isn’t very HA or good anyways. We’ll most likely not need this for
    # long though. If we do, we need to find a better way, e.g. by extending
    # ch-k8s-lbaas to support cluster IPs locally on the agents.
    route {{ k8s_network_service_subnet }} via {{ hostvars[groups['masters'][0]].local_ipv4_address }};
    import all;
    export none;
}

{% for hostname in groups['k8s_nodes'] %}
{% set peer = hostvars[hostname] %}
protocol bgp {{ hostname | replace('-', '_') }} {
    table master;
    local {{ local_ipv4_address }} as 65000;
    neighbor {{ peer.local_ipv4_address }} as 64512;
    multihop;
    import all;
    export filter {
        print "in bgp export with ", net;
        if net ~ 10.3.0.1/32 then {
            print "accepting";
            accept;
        } else {
            print "rejecting";
            print "10.3.0.1/32";
            print net;
            reject;
        }
    };
}

{% endfor %}
