
{ config, lib, ...}: let

  # rangeToAttrs =
  # modulo =
locals ={
  gateway_nodes = rangeToAttrs (lib.lists.range config.var.gateway_count) (idx: {
      "${local.nodes_prefix}${config.var.gateway_defaults.common_name}${idx}" = {
        image                    = config.var.gateway_defaults.image;
        flavor                   = config.var.gateway_defaults.flavor;
        az                       = if config.var.spread_gateways_across_azs
          then builtins.elem (modulo idx (builtins.length config.var.azs)) config.var.azs
          else null;
        volume_name              = "${local.nodes_prefix}${config.var.gateway_defaults.common_name}${idx}-volume";
        root_disk_size           = config.var.gateway_defaults.root_disk_size;
        root_disk_volume_type    = config.var.gateway_defaults.root_disk_volume_type;
      }
  });
};

 in {
resource."openstack_networking_port_v2"."gw_vip_port" ={
  name = "${config.var.cluster_name}-gateway-vip";
  admin_state_up = true;
  network_id     = lib.tfRef "openstack_networking_network_v2.cluster_network.id";

  fixed_ip =
    (lib.optional config.var.ipv4_enabled {
        subnet_id = lib.tfRef "openstack_networking_subnet_v2.cluster_subnet[0].id";
    }) ++
    (lib.optional config.var.ipv6_enabled
    {
        subnet_id = lib.tfRef "openstack_networking_subnet_v2.cluster_v6_subnet[0].id";
    })
  ;
};

resource."openstack_networking_floatingip_v2"."gw_vip_fip" ={
  pool        = config.var.public_network;
  description = "Floating IP associated with the VRRP port";
  port_id     = lib.tfRef "openstack_networking_port_v2.gw_vip_port.id";

  depends_on = [
    (lib.tfRef "openstack_networking_router_interface_v2.cluster_router_iface[0]")
  ];
};


resource."openstack_networking_port_v2"."gateway" = lib.attrsets.mapAttrs (name: _: {
  inherit name;

  network_id = lib.tfRef "openstack_networking_network_v2.cluster_network.id";

  fixed_ip =
    (lib.optional config.var.ipv4_enabled {
        subnet_id = lib.tfRef "openstack_networking_subnet_v2.cluster_subnet[0].id";
    }) ++
    (lib.optional config.var.ipv6_enabled
    {
        subnet_id = lib.tfRef "openstack_networking_subnet_v2.cluster_v6_subnet[0].id";
    })
  ;

  port_security_enabled = false;
}) local.gateway_nodes;

resource."openstack_blockstorage_volume_v3"."gateway-volume" ={
  for_each = config.var.create_root_disk_on_volume == true ? local.gateway_nodes : {}
  name        = each.value.volume_name
  size        = (data.openstack_compute_flavor_v2.gateway.disk > 0) ? data.openstack_compute_flavor_v2.gateway.disk : each.value.root_disk_size
  image_id    = data.openstack_images_image_v2.gateway.id
  volume_type = each.value.root_disk_volume_type
  availability_zone = each.value.az

  timeouts {
    create = config.var.timeout_time
    delete = config.var.timeout_time
  }

  lifecycle {
    ignore_changes = [image_id]
  }
}

resource."openstack_compute_instance_v2"."gateway" ={
  for_each = local.gateway_nodes

  name              = each.key
  flavor_id         = data.openstack_compute_flavor_v2.gateway.id
  image_id          = config.var.create_root_disk_on_volume == false ? data.openstack_images_image_v2.gateway.id : null
  key_pair          = config.var.keypair
  availability_zone = each.value.az
  config_drive      = true

  dynamic block_device {
    # Using "for_each" for check the conditional "create_root_disk_on_volume". It's not working as a loop. "dummy" should make this just more visible.
    for_each = config.var.create_root_disk_on_volume == true ? ["dummy"] : []
      content {
      uuid                  = openstack_blockstorage_volume_v3.gateway-volume[each.key].id
      source_type           = "volume"
      boot_index            = 0
      destination_type      = "volume"
      delete_on_termination = true
      }
  }

  network {
    port = openstack_networking_port_v2.gateway[each.key].id
  }
  lifecycle {
    ignore_changes = [key_pair, image_id, config_drive]
  }
}

resource."openstack_networking_floatingip_v2"."gateway" ={
  for_each    = local.gateway_nodes
  description = "Floating IP for gateway '${each.key}'${each.value.az != null ? " in ${each.value.az}" : ""}"
  pool        = config.var.public_network
}

resource."openstack_compute_floatingip_associate_v2"."gateway" ={
  for_each = openstack_compute_instance_v2.gateway

  floating_ip = openstack_networking_floatingip_v2.gateway[each.key].address
  instance_id = each.value.id

  depends_on = [
    openstack_networking_router_interface_v2.cluster_router_iface[0]
  ]
}

data "template_file" "trampoline_gateways" {
  template = file("${path.module}/templates/trampoline_gateways.tpl")
  vars = {
    networking_fixed_ip      = try(jsonencode(openstack_networking_port_v2.gw_vip_port.all_fixed_ips[0]), "null"),
    networking_fixed_ip_v6   = try(jsonencode(openstack_networking_port_v2.gw_vip_port.all_fixed_ips[1]), "null"),
    wireguard_gw_fixed_ip_v6 = try(jsonencode(openstack_networking_port_v2.gw_vip_port.all_fixed_ips[2]), "null"),
    networking_floating_ip  = openstack_networking_floatingip_v2.gw_vip_fip.address,
    subnet_cidr             = try(jsonencode(openstack_networking_subnet_v2.cluster_subnet[0].cidr), "null"),
    subnet_v6_cidr          = try(jsonencode(openstack_networking_subnet_v2.cluster_v6_subnet[0].cidr), "null"),
    ipv6_enabled       = config.var.ipv6_enabled,
    ipv4_enabled       = config.var.ipv4_enabled,
  }
}
}
